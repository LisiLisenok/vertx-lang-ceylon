@includeNamed{'/vertx-java/template/common-lib.templ'}
@includeNamed{'ceylon-common.templ'}
@code{

  /*
   * Returns the Ruby class qualified name for a given Vert.x Api interface
   * (for instance io.vertx.core.Vertx -> Vertx::Vertx), the generated name uses the module name the
   * Api interface belongs to.
   * @param type the type
   */
  def genRubyClassFqn(type) {
    return "::" + type.module.getName(CASE_CAMEL) + "::" + type.simpleName;
  }

  def genRubyDocType(type) {

    var kind = type.kind;
    if (kind == CLASS_OBJECT) {
      return "Object";
    } else if (kind == CLASS_JSON_OBJECT) {
      return "Hash{String => Object}";
    } else if (kind == CLASS_JSON_ARRAY) {
      return "Array<String,Object>";
    } else if (kind == CLASS_ASYNC_RESULT) {
      return "AsyncResult"; /* Find something better than that... */
    } else if (kind == CLASS_HANDLER) {
      return "Proc";
    } else if (kind.collection) {
      if (kind == CLASS_LIST) {
        return "Array<" + genRubyDocType(type.args[0]) + ">";
      } else if (kind == CLASS_SET) {
        return "Set<" + genRubyDocType(type.args[0]) + ">";
      } else if (kind == CLASS_MAP) {
        return "Hash{" + genRubyDocType(type.args[0]) + " => " + genRubyDocType(type.args[1]) + "}";
      }
    } else if (kind == CLASS_DATA_OBJECT) {
      return "Hash"; /* can we do something better ? */
    } else if (kind == CLASS_ENUM) {
      var buffer = "";
      boolean index = 0;
      for (value : type.values) {
        if (index > 0) {
          buffer += ",";
        }
        buffer += ":" + value;
        index = index + 1;
      }
      return buffer;
    } else if (kind.basic) {
      if (kind == CLASS_STRING) {
        return "String";
      } else {
        var typeName = type.name;
        if (typeName == "byte" || typeName == "java.lang.Byte" ||
            typeName == "short" || typeName == "java.lang.Short" ||
            typeName == "int" || typeName == "java.lang.Integer" ||
            typeName == "char" || typeName == "java.lang.Character" ||
            typeName == "long" || typeName == "java.lang.Long") {
          return "Fixnum";
        }
        if (typeName == "float" || typeName == "java.lang.Float" ||
            typeName == "double" || typeName == "java.lang.Double") {
          return "Float";
        }
        if (typeName == "boolean" || typeName == "java.lang.Boolean") {
          return "true,false";
        }
      }
    } else if (kind == CLASS_API) {
      return genRubyClassFqn(type.raw);
    }
    System.out.println("Untranslated type " + type + " with kind " + kind);
    return "Nil";
  }

  def renderLinkToHtml(link) {
    var rawType = link.targetType.raw;
    var label = link.label.trim();
    if (rawType.module != null) {
      var elt = link.targetElement;
      var rubyType = genRubyDocType(rawType);
      var kind = elt.getKind().name();
      if (kind == "CLASS" || kind == "INTERFACE") {
        return "{" + rubyType + label + "}";
      } else if (kind == "METHOD") {
        return "{" + rubyType + "#" + CASE_SNAKE.format(CASE_CAMEL.parse(elt.getSimpleName().toString())) + (label.length() > 0 ? " " : "") + label + "}";
      } else {
        System.out.println("Unhandled kind " + kind + " for " + link.targetType);
      }
    } else {
      if (label != null) {
        return label;
      } else {
        return genRubyDocType(link.targetType);
      }
    }
  }

  /*
   * Returns the Ruby class qualified name for the Java type suitable for creating instances of the type
   * (for instance java.util.HashMap -> Java::JavaUtil::HashMap), the generated name uses the package name
   * of the type.
   * @param type the type
   */
  def genJavaClassFqn(type) {
    var kind = type.getKind();
    if (kind == CLASS_PRIMITIVE) {
      return "Java::" + type.simpleName;
    } else if (kind == CLASS_STRING) {
      return "Java::java.lang.String";
    } else if (kind == CLASS_HANDLER) {
      return "Java::IoVertxCore::Handler";
    } else if (kind == CLASS_OBJECT) {
      return "Java::java.lang.Object";
    } else {
      type = type.raw;
      return  "Java::" + CASE_CAMEL.format(CASE_QUALIFIED.parse(type.packageName)) + "::" + type.simpleName;
    }
  }

  /* Ruby reserved words */
  var reservedWords = new java.util.HashSet();
  reservedWords.add("alias");
  reservedWords.add("and");
  reservedWords.add("BEGIN");
  reservedWords.add("begin");
  reservedWords.add("def");
  reservedWords.add("elsif");
  reservedWords.add("END");
  reservedWords.add("end");
  reservedWords.add("ensure");
  reservedWords.add("in");
  reservedWords.add("module");
  reservedWords.add("next");
  reservedWords.add("nil");
  reservedWords.add("not");
  reservedWords.add("or");
  reservedWords.add("redo");
  reservedWords.add("rescue");
  reservedWords.add("retry");
  reservedWords.add("self");
  reservedWords.add("then");
  reservedWords.add("undef");
  reservedWords.add("unless");
  reservedWords.add("until");
  reservedWords.add("when");
  reservedWords.add("yield");

  /*
   * Generate a correct ruby name that does not clash with an identifier.
   */
  def genRubyName(name) {
    if (reservedWords.contains(name)) {
      return "_" + name
    } else {
      return name;
    }
  }

  /*
   * Generate a ruby method name for a given method.
   */
  def genMethodName(method) {
    return toCeylonIdentifier(method.name);
  }

  /*
   * Returns the predicate for the specified type and expression that validates a Ruby object can be converted
   * to a specified Java object.
   * @param expr the expression that evaluates to the object to validate
   * @param type the type to validate
   */
  def genTypeCheckPredicate(expr, type) {
    var kind = type.kind;
    if (kind == CLASS_STRING) {
      return expr + ".class == String";
    } else if (kind == CLASS_ENUM) {
      return expr + ".class == Symbol";
    } else if (kind.basic) {
      var typeName = type.name;
      if (typeName == "byte" || typeName == "java.lang.Byte" ||
          typeName == "short" || typeName == "java.lang.Short" ||
          typeName == "int" || typeName == "java.lang.Integer" ||
          typeName == "char" || typeName == "java.lang.Character" ||
          typeName == "long" || typeName == "java.lang.Long") {
        return expr + ".class == Fixnum";
      }
      if (typeName == "float" || typeName == "java.lang.Float" ||
          typeName == "double" || typeName == "java.lang.Double") {
        return expr + ".class == Float";
      }
      if (typeName == "boolean" || typeName == "java.lang.Boolean") {
        return "(" + expr + ".class == TrueClass || " + expr + ".class == FalseClass)";
      }
    } else if (kind == CLASS_OBJECT) {
      return "(" + expr + ".class == String  || " + expr + ".class == Hash || " + expr + ".class == Array || "
      + expr + ".class == NilClass || " + expr + ".class == TrueClass || " + expr + ".class == FalseClass || "
      + expr + ".class == Fixnum || " + expr + ".class == Float)";
    } else if (kind == CLASS_API) {
      return expr + ".class.method_defined?(:j_del)";
    } else if (kind == CLASS_HANDLER) {
      return expr + ".class == Proc";
    } else if (kind == CLASS_DATA_OBJECT || kind == CLASS_JSON_OBJECT) {
      return expr + ".class == Hash";
    } else if (kind == CLASS_JSON_ARRAY) {
      return expr + ".class == Array";
    } else if (kind == CLASS_LIST) {
      return expr + ".class == Array";
    } else if (kind == CLASS_SET) {
      return expr + ".class == Set";
    } else if (kind == CLASS_MAP) {
      return expr + ".class == Hash";
    }
    return "false";
  }

  /*
   * Returns the method call for a given method.
   * @param method the called method
   * @param params the parameter names to use
   */
  def old_genMethodCall(method,params) {
    var args = "(";
    var signature = "(:" + method.getName() + ", [";
    var index = 1;
    if (method.params.size() > 0) {
      for (param : method.params) {
        if (param != method.params[0]) {
          args += ",";
          signature += ",";
        }
        args += genConvParam(param.type, params[index - 1]);
        signature += genJavaClassFqn(param.type) + ".java_class";
        index += 1;
      }
    }
    args += ")";
    signature += "])";
    /*
    return "(Java::IoVertxLangRuby::Helper.fixJavaMethod(" + (method.staticMethod ? genJavaClassFqn(type) : "@j_del") +
       ".java_class.declared_method" + signature +
       ")).invoke" + args;
    */
    return (method.staticMethod ? genJavaClassFqn(type) : "@j_del") + ".java_method" + signature + ".call" + args;
  }

  def genConvParam(type, expr) {
    var kind = type.kind;
    if (kind.basic) {
      var sname = type.simpleName;
      if (sname == 'int' || sname == 'short' || sname == 'float' || sname == 'char') {
        return '(' + sname + ')' + expr;
      } else if (sname == 'Boolean') {
        return expr + '.booleanValue()';
      } else if (sname == 'Byte') {
        return expr + '.byteValue()';
      } else if (sname == 'Short') {
        return '(short)' + expr + '.longValue()';
      } else if (sname == 'Integer') {
        return '(int)' + expr + '.longValue()';
      } else if (sname == 'Long') {
        return expr + '.longValue()';
      } else if (sname == 'Float') {
        return '(float)' + expr + '.doubleValue()';
      } else if (sname == 'Double') {
        return expr + '.doubleValue()';
      } else if (sname == 'Character') {
        return '(char)' + expr + '.intValue()';
      } else if (sname == 'String') {
        return expr + ".toString()";
      }
      return expr;
    } else if (kind == CLASS_HANDLER) {
      var eventType = type.args[0];
      var eventKind = eventType.kind;
      if (eventKind == CLASS_ASYNC_RESULT) {
        var resultType = eventType.args[0];
        var resultKind = resultType.kind;
        var adapterType = resultType.erased;
        return 'new io.vertx.lang.ceylon.AsyncResultAdapter<' + adapterType.name + '>(' + expr + ') { public Object toCeylon(' + adapterType.name + ' event) { return ' + genConvReturn(adapterType, 'event') + '; } }';
      } else if (eventKind == CLASS_VOID) {
        /* Special case */
        return 'new ' + type.erased.name + '() { public void handle(' + type.erased.args[0].name + ' event) { ' + expr + '.$call$(); } }';
      } else {
        return 'new ' + type.erased.name + '() { public void handle(' + type.erased.args[0].name + ' event) { ' + expr + '.$call$((Object)' + genConvReturn(type.erased.args[0], 'event') + '); } }';
      }
    } else if (kind == CLASS_API) {
      return '(' + type.erased.name + ')' + expr + ".getDelegate()";
    } else if (kind == CLASS_OBJECT) {
      return 'io.vertx.lang.ceylon.Helper.toJavaObject(' + expr + ')';
    } else if (kind == CLASS_DATA_OBJECT) {
      return expr + ' == null ? null : new ' + type.name + '(io.vertx.lang.ceylon.Helper.toJsonObject(' + expr + '.toJson()))';
    } else if (kind == CLASS_JSON_OBJECT) {
    } else if (kind == CLASS_JSON_ARRAY) {
    } else if (kind == CLASS_ENUM) {
    } else if (kind == CLASS_LIST || kind == CLASS_SET) {
      var collection = kind == CLASS_LIST ? 'io.vertx.lang.ceylon.ToJava.list' : 'io.vertx.lang.ceylon.ToJava.set';
      var eltType = type.args[0];
      var eltKind = eltType.kind;
      if (eltKind.basic || eltKind.json) {
        return collection + '(' + expr + ', ' + 'io.vertx.lang.ceylon.ToJava.' + eltType.simpleName + ')';
      } else if (eltKind == CLASS_API) {
        return collection + '(' + expr + ', ' + eltType.translateName('ceylon') + '.TO_JAVA)';
      } else if (eltKind == CLASS_DATA_OBJECT) {
        return collection + '(' + expr + ', ' + eltType.translatePackageName('ceylon') + '.toJava' + eltType.simpleName + '_.get_()' + ')';
      }
    } else if (kind == CLASS_SET) {
    } else if (kind == CLASS_MAP) {
    }
    return 'null';
  }

  def genConvParamType(type) {
    var kind = type.kind;
    if (kind == CLASS_OBJECT) {
      return 'Object';
    }
    if (kind == CLASS_VOID) {
      return "Void_";
    }
    if (kind == CLASS_STRING) {
      return "String_";
    }
    if (kind.basic) {
      var name = type.simpleName;
      if (name == 'byte' || name == 'Byte') {
        return 'Byte_';
      }
      if (name == 'short' || name == 'Short') {
        return 'Short_';
      }
      if (name == 'Integer' || name == 'int' ) {
        return 'Integer_';
      }
      if (name == 'Long' || name == 'long') {
        return 'Long_';
      }
      if (name == 'boolean' || name == 'Boolean') {
        return 'Boolean_';
      }
      if (name == 'float' || name == 'Float') {
        return 'Float_';
      }
      if (name == 'double' || name == 'Double') {
        return 'Double_';
      }
      if (name == 'char' || name == 'Character') {
        return 'Character_';
      }
    }
    if (kind == CLASS_API) {
      var s = type.raw.simpleName + '_';
      if (type instanceof io.vertx.codegen.TypeInfo$Parameterized) {
        s += genConvParamTypeArgs(type.args);
      }
      return s;
    }
    if (kind == CLASS_DATA_OBJECT) {
      return type.simpleName + "_";
    }
    if (kind == CLASS_JSON_OBJECT) {
      return "JsonObject_";
    }
    if (kind == CLASS_JSON_ARRAY) {
      return "JsonArray_";
    }
    if (kind == CLASS_LIST || kind == CLASS_SET) {
      return type.raw.simpleName + '_' + genConvParamTypeArgs(type.args);
    }
    if (kind == CLASS_THROWABLE) {
      return "Throwable";
    }
    return 'Nothing';
  }

  def genConvParamTypeArgs(typeArgs) {
    StringBuilder s = new java.lang.StringBuilder();
    s.append('<');
    var sep = '';
    for (typeArg : typeArgs) {
      s.append(sep).append(genConvParamType(typeArg));
      sep = ',';
    }
    s.append('>');
    return s.toString();
  }

  /*
   * Returns the Ruby expression that converts a Java object to a Ruby object.
   * @param type the type of the Java object
   * @param expr the expression that evaluates to the Java object
   */
  def genConvReturn(type, expr) {
    if (type.name.equals("void")) {
      return expr;
    } else {
      var kind = type.kind;
      if (kind.basic || kind == CLASS_THROWABLE) {
        if (type.name == 'java.lang.Byte') {
          return 'ceylon.language.Byte.instance(' + expr + ')';
        } else if (type.name == 'java.lang.Short') {
          return 'ceylon.language.Integer.instance((long)(short)' + expr + ')';
        } else if (type.name == 'java.lang.Integer') {
          return 'ceylon.language.Integer.instance((long)(int)' + expr + ')';
        } else if (type.name == 'java.lang.Long') {
          return 'ceylon.language.Integer.instance(' + expr + ')';
        } else if (type.name == 'java.lang.Float') {
          return 'ceylon.language.Float.instance((float)' + expr + ')';
        } else if (type.name == 'java.lang.Double') {
          return 'ceylon.language.Float.instance(' + expr + ')';
        } else if (type.name == 'java.lang.Boolean') {
          return 'ceylon.language.Boolean.instance(' + expr + ')';
        } else if (type.name == 'java.lang.Character') {
          return 'ceylon.language.Character.instance(' + expr + ')';
        } else if (type.name == 'java.lang.String') {
          return 'new ceylon.language.String(' + expr + ')';
        }
        return expr;
      } else if (kind == CLASS_DATA_OBJECT) {
        return type.translatePackageName('ceylon') + '.to' + type.simpleName + '_.get_().convert(' + expr + ')';
      } else if (kind == CLASS_LIST || kind == CLASS_SET) {
        var collection = kind == CLASS_LIST ? 'io.vertx.lang.ceylon.ToCeylon.list' : 'io.vertx.lang.ceylon.ToCeylon.set';
        var typeArg = type.args[0];
        if (typeArg.kind.basic || typeArg.kind.json) {
          return collection + '(' + genCeylonTypeDecl(typeArg).replace('::', '.') + '.$TypeDescriptor$, ' + expr + ', io.vertx.lang.ceylon.ToCeylon.' + typeArg.simpleName + ')';
        } else if (typeArg.kind == CLASS_DATA_OBJECT) {
          return collection + '(' + genCeylonTypeDecl(typeArg).replace('::', '.') + '.$TypeDescriptor$, ' + expr + ', ' + typeArg.translatePackageName('ceylon') + '.to' + typeArg.simpleName + '_.get_())';
        } else if (typeArg.kind == CLASS_API) {
          return collection + '(' + typeArg.translateName('ceylon') + '.$TypeDescriptor$, ' + expr + ', ' + typeArg.translateName('ceylon') + '.TO_CEYLON)';
        }
      } else if (kind == CLASS_MAP) {
        var valueType = type.args[1];
        var valueKind = valueType.kind;
        if (valueKind == CLASS_JSON_OBJECT) {
        } else if (valueKind == CLASS_JSON_ARRAY) {
        } else if (valueKind.basic) {
        }
      } else if (kind == CLASS_API) {
        return 'new ' + type.raw.translateName('ceylon') + (type.raw.concrete ? '' : '.Impl') + '(' + expr + ')';
      } else if (kind.json) {
      } else if (kind == CLASS_OBJECT) {
        return 'io.vertx.lang.ceylon.ToCeylon.object(' + expr + ')';
      } else if (kind == CLASS_ENUM) {
      }
    }
    return 'null';
  }

  /*
   * Generate Java type declaration for Ceylon interrop.
   */
  def genJavaInterropTypeDecl(type) {
    var decl = "not_handled: " + type + " " + type.class + " " + type.kind;
    var kind = type.kind;
    if (kind == CLASS_API) {
      decl = type.simpleName;
      if (type instanceof io.vertx.codegen.TypeInfo$Parameterized) {
        decl = genJavaInterropTypeDecl(type.raw);
        var sep = '<';
        for (typeArg : type.args) {
          decl += sep + genJavaInterropTypeDecl(typeArg);
          sep = ',';
        }
        decl += '>';
      }
    } else if (kind == CLASS_STRING || kind == CLASS_ENUM) {
      decl = 'ceylon.language.String';
    } else if (kind == CLASS_BOXED_PRIMITIVE) {
      var name = type.name;
      if (name == 'java.lang.Long' || name == 'java.lang.Integer' || name == 'java.lang.Short') {
        decl = 'ceylon.language.Integer';
      } else if (name == 'java.lang.Float' || name == 'java.lang.Double') {
        decl = 'ceylon.language.Float';
      } else if (name == 'java.lang.Boolean') {
        decl = 'ceylon.language.Boolean';
      } else if (name == 'java.lang.Character') {
        decl = 'ceylon.language.Character';
      } else if (name == 'java.lang.Byte') {
        decl = 'ceylon.language.Byte';
      }
    } else if (kind == CLASS_PRIMITIVE) {
      var name = type.name;
      if (name == 'long' || name == 'int' || name == 'short') {
        decl = 'long';
      } else if (name == 'float' || name == 'double') {
        decl = 'double';
      } else if (name == 'boolean') {
        decl = 'boolean';
      } else if (name == 'char') {
        decl = 'int';
      } else if (name == 'byte') {
        decl = 'byte';
      }
    } else if (kind == CLASS_OBJECT) {
      /* handle this instanceof better */
      if (type instanceof io.vertx.codegen.TypeInfo$Variable) {
        decl = type.name;
      } else {
        decl = 'Object';
      }
    } else if (kind == CLASS_HANDLER) {
      var arg = type.args[0];
      decl = 'Callable<?>';
    } else if (kind == CLASS_THROWABLE) {
      decl = 'Throwable';
    } else if (kind == CLASS_DATA_OBJECT) {
      decl = type.translatePackageName('ceylon') + "." + type.simpleName;
    } else if (kind == CLASS_VOID) {
      decl = 'Anything';
    } else if (kind == CLASS_LIST) {
      decl = 'ceylon.language.List<' + genJavaInterropTypeDecl(type.args[0]) + '>';
    } else if (kind == CLASS_SET) {
      decl = 'ceylon.language.Set<' + genJavaInterropTypeDecl(type.args[0]) + '>';
    } else if (kind == CLASS_MAP) {
      decl = 'Map<' + genJavaInterropTypeDecl(type.args[0]) + ',' + genJavaInterropTypeDecl(type.args[1]) + '>';
    } else if (kind == CLASS_JSON_OBJECT) {
      decl = 'ceylon.json.Object';
    } else if (kind == CLASS_JSON_ARRAY) {
      decl = 'ceylon.json.Array';
    } else if (kind == CLASS_OTHER) {
      if (type instanceof io.vertx.codegen.TypeInfo$Void) {
        decl = 'void';
      }
    }
    return decl;
  }

  /*
   * Generate Ceylon type declaration.
   */
  def genCeylonTypeDecl(type) {
    var decl = "not_handled: " + type + " " + type.class + " " + type.kind;
    var kind = type.kind;
    if (kind == CLASS_API) {
      decl = type.raw.translatePackageName('ceylon') + "::" + type.simpleName;
      if (type instanceof io.vertx.codegen.TypeInfo$Parameterized) {
        decl = genCeylonTypeDecl(type.raw);
        var sep = '<';
        for (typeArg : type.args) {
          decl += sep + genCeylonTypeDecl(typeArg);
          sep = ',';
        }
        decl += '>';
      }
    } else if (kind == CLASS_STRING || kind == CLASS_ENUM) {
      decl = 'ceylon.language::String';
    } else if (kind == CLASS_BOXED_PRIMITIVE) {
      var name = type.name;
      if (name == 'java.lang.Long' || name == 'java.lang.Integer' || name == 'java.lang.Short') {
        decl = 'ceylon.language::Integer';
      } else if (name == 'java.lang.Float' || name == 'java.lang.Double') {
        decl = 'ceylon.language::Float';
      } else if (name == 'java.lang.Boolean') {
        decl = 'ceylon.language::Boolean';
      } else if (name == 'java.lang.Character') {
        decl = 'ceylon.language::Character';
      } else if (name == 'java.lang.Byte') {
        decl = 'ceylon.language::Byte';
      }
    } else if (kind == CLASS_PRIMITIVE) {
      var name = type.name;
      if (name == 'long' || name == 'int' || name == 'short') {
        decl = 'ceylon.language::Integer';
      } else if (name == 'float' || name == 'double') {
        decl = 'ceylon.language::Float';
      } else if (name == 'boolean') {
        decl = 'ceylon.language::Boolean';
      } else if (name == 'char') {
        decl = 'ceylon.language::Character';
      } else if (name == 'byte') {
        decl = 'ceylon.language::Byte';
      }
    } else if (kind == CLASS_OBJECT) {
      /* handle this instanceof better */
      if (type instanceof io.vertx.codegen.TypeInfo$Variable) {
        decl = type.name;
      } else {
        decl = 'ceylon.language::Object';
      }
    } else if (kind == CLASS_HANDLER) {
      var arg = type.args[0];
      if (arg.kind == CLASS_VOID) {
        decl = 'ceylon.language::Anything()';
      } else if (arg.kind == CLASS_ASYNC_RESULT) {
        var result = arg.args[0];
        if (result.kind == CLASS_VOID) {
          decl = 'ceylon.language::Anything(ceylon.language::Throwable?)';
        } else {
          decl = 'ceylon.language::Anything(ceylon.language::Throwable|' + genCeylonTypeDecl(result) + ')';
        }
      } else {
        decl = 'ceylon.language::Anything(' + genCeylonTypeDecl(type.args[0]) + ')';
      }
    } else if (kind == CLASS_THROWABLE) {
      decl = 'ceylon.language::Throwable';
    } else if (kind == CLASS_DATA_OBJECT) {
      decl = type.translatePackageName('ceylon') + "::" + type.simpleName;
    } else if (kind == CLASS_VOID) {
      decl = 'ceylon.language::Anything';
    } else if (kind == CLASS_SET) {
      decl = 'ceylon.language::Set<' + genCeylonTypeDecl(type.args[0]) + '>';
    } else if (kind == CLASS_LIST) {
      decl = 'ceylon.language::List<' + genCeylonTypeDecl(type.args[0]) + '>';
    } else if (kind == CLASS_MAP) {
      decl = 'ceylon.language::Map<' + genCeylonTypeDecl(type.args[0]) + ',' + genCeylonTypeDecl(type.args[1]) + '>';
    } else if (kind == CLASS_JSON_OBJECT) {
      decl = 'ceylon.json::Object';
    } else if (kind == CLASS_JSON_ARRAY) {
      decl = 'ceylon.json::Array';
    } else if (kind == CLASS_OTHER) {
      if (type instanceof io.vertx.codegen.TypeInfo$Void) {
        decl = 'ceylon.language::Anything';
      }
    }
    return decl;
  }
}

@declare{'initializer'}
    # @private\n
    # @param j_del [@{genRubyClassFqn(type.raw)}] the java delegate\n
    def initialize(j_del)\n
	@if{callSuper}
      super(j_del)\n
	@end{}
      @j_del = j_del\n
    end\n
    # @private\n
    # @return [@{genRubyClassFqn(type.raw)}] the underlying java delegate\n
    def j_del\n
      @j_del\n
    end\n
@end{}

@declare{'genTypeParams'}
	@if{params.size() > 0}
		<@foreach{param:params}
		@{param.name}
		@end{','}>
	@end{}
@end{}

@declare{'genExtendsClause'}
	@if{concreteSuperTypes.size() > 0}extends @{genTypeDecl(concreteSuperTypes[0])}(delegate) @end{}
@end{}

@code{
  def genSatisfiesClause() {
    var s = new java.lang.StringBuilder();
    var sep = 'satisfies ';
    for(superType : abstractSuperTypes) {
      s.append(sep).append(genTypeDecl(superType));
      sep = '& ';
    }
    return s.toString();
  }
}

@code{
  def genDelegateType(type) {
    StringBuilder s = new java.lang.StringBuilder();
    s.append(type.raw.simpleName).append('_');
    if (type.raw.params.size() > 0) {
      s.append('<');
      var sep = '';
      for (typeParam : type.raw.params) {
        s.append(sep).append('Object');
        sep = ',';
      }
      s.append('>');
    }
    return s.toString();
  }
}

@declare{'genMethodParams'}
[@foreach{param:method.params}@{genTypeDecl(param.type)}@end{','}]
@end{}

@declare{'genMethodArgs'}
@foreach{method:methods}@includeNamed{'genMethodParams'}@end{'|'}
@end{}

@code{
  def genMethodCallCeylon(method, indent) {
    var sb = new java.lang.StringBuilder();
    var args = new java.util.ArrayList();
    var idx = 0;
    for (param : method.params) {
      if (param.type.kind == CLASS_API) {
        sb.append(indent).append('assert(is Delegating<').append(genConvParamType(param.type)).append('> arg_').append(idx).append(' = args[').append(idx).append(']);\n');
        args.add('arg_' + idx + '.delegate');
      } else {
        sb.append(indent).append(genConvParam(param.type, 'arg_' + idx, 'args[' + idx + ']')).append(';\n');
        args.add('arg_' + idx);
      }
      idx += 1;
    }
    sb.append(indent);
    if (isGetterMethod(method)) {
      sb.append('Anything v = delegate.').append(toCeylonIdentifier(getPropertyNameFromGetter(method)));
    } else if (isSetterMethod(method)) {
      sb.append('delegate.').append(toCeylonIdentifier(getPropertyNameFromSetter(method))).append(' = ').append(args[0]);
    } else {
      sb.append('Anything v = delegate.').append(genMethodName(method)).append('(');
      var paramIdx = 0;
      for (param : method.params) {
        if (paramIdx > 0) {
          sb.append(',');
        }
        sb.append(args[paramIdx]);
        paramIdx += 1;
      }
      sb.append(')');
    }
    sb.append(';\n');
    return sb.toString();
  }
}

@code{
  def genMethodCall(method, indent) {
    var sb = new java.lang.StringBuilder();
    var args = new java.util.ArrayList();
    var idx = 0;
    for (param : method.params) {
      var arg = 'arg_' + idx;
      sb.append(indent);
      sb.append(param.type.erased);
      sb.append(' ');
      sb.append(arg);
      sb.append(' = ');
      sb.append(genConvParam(param.type, param.name));
      sb.append(';\n');
      idx += 1;
    }
    var expr = new java.lang.StringBuilder();
    if (method.staticMethod) {
      expr.append(type.raw.name);
    } else {
      expr.append('delegate');
    }
    expr.append('.').append(method.name).append('(');
    var paramIdx = 0;
    for (param : method.params) {
      if (paramIdx > 0) {
        expr.append(', ');
      }
      expr.append('arg_' + paramIdx);
      paramIdx += 1;
    }
    expr.append(')');
    sb.append(indent);
    if (method.returnType.name != 'void') {
      sb.append(genJavaInterropTypeDecl(method.returnType)).append(' ret = ');
    }
    sb.append(genConvReturn(method.returnType, expr.toString()));
    sb.append(';\n');
    if (method.returnType.name != 'void') {
      sb.append(indent).append('return ret;\n');
    }
    return sb.toString();
  }
}

@declare{'genTypeParamsDesc'}
@{indent}@TypeParameters({\n
	@foreach{param:params}
@{indent}  @TypeParameter(value="@{param.name}",variance=Variance.NONE)
	@end{',\n'}
\n@{indent}})\n
@end{}

@declare{'genClassCtor'}
@{indent}@Ignore\n
@{indent}private final @{type.raw.name} delegate;\n
\n
@{indent}public @{ctor}(@{type.raw.name} delegate) {\n
@{indent}  this.delegate = delegate;\n
@{indent}}\n
\n
@{indent}@Ignore\n
@{indent}public Object getDelegate() {\n
@{indent}  return delegate;\n
@{indent}}\n
@end{}

@comment{"Generate the imports"}
package @{type.raw.translatePackageName('ceylon')};\n

\n
import com.redhat.ceylon.compiler.java.metadata.TypeInfo;\n
import com.redhat.ceylon.compiler.java.metadata.TypeParameter;\n
import com.redhat.ceylon.compiler.java.metadata.TypeParameters;\n
import com.redhat.ceylon.compiler.java.metadata.Variance;\n
import com.redhat.ceylon.compiler.java.metadata.Ignore;\n
import com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor;\n
import ceylon.language.Callable;\n
import ceylon.language.DocAnnotation$annotation$;\n
@foreach{importedType:importedTypes}

	@if{importedType.kind == CLASS_DATA_OBJECT}
	@else{importedType.kind == CLASS_API}
		@if{!ifacePackageName.equals(importedType.packageName)}
			import @{importedType.raw.translateName("ceylon")};\n
		@end{}
	@else{}
		@if{!importedType.packageName.equals("java.lang")}
			import @{importedType};\n
		@end{}
	@end{}
@end{}

\n
@if{typeParams.size() > 0}
@includeNamed{'genTypeParamsDesc';params=typeParams;indent=''}
@end{}
@DocAnnotation$annotation$(description = "todo")\n
public @if{concrete}class@else{}interface@end{} @{type.raw.simpleName}@includeNamed{'genTypeParams';params=typeParams}
@if{abstractSuperTypes.size() > 0}
	 @if{concrete}implements@else{}extends@end{}
	@foreach{abstractSuperType:abstractSuperTypes}
	 @{genJavaInterropTypeDecl(abstractSuperType)}
	@end{','}
@end{} {\n

\n
  @if{concrete}public static final @end{}TypeDescriptor $TypeDescriptor$ = TypeDescriptor.klass(@{type.raw.simpleName}.class);\n

\n
  @if{concrete}public static final @end{}io.vertx.lang.ceylon.Converter<@{type.raw.name}, @{type.raw.simpleName}> TO_CEYLON = new io.vertx.lang.ceylon.Converter<@{type.raw.name}, @{type.raw.simpleName}>() {\n
    public @{type.raw.simpleName} convert(@{type.raw.name} src) {\n
      return new @{type.raw.simpleName}@if{!concrete}.Impl@end{}(src);\n
    }\n
  };\n

\n
  @if{concrete}public static final @end{}io.vertx.lang.ceylon.Converter<@{type.raw.simpleName}, @{type.raw.name}> TO_JAVA = new io.vertx.lang.ceylon.Converter<@{type.raw.simpleName}, @{type.raw.name}>() {\n
    public @{type.raw.name} convert(@{type.raw.simpleName} src) {\n
@if{concrete}
      return src.delegate;\n
@else{}
      return (@{type.raw.name})src.getDelegate();\n
@end{}
    }\n
  };\n


\n
@if{concrete}
@includeNamed{'genClassCtor';indent='  ';ctor=type.raw.simpleName}
@else{}
  @Ignore\n
  Object getDelegate();\n
@end{}

@foreach{method:methods}
\n
@if{method.typeParams.size() > 0}
@includeNamed{'genTypeParamsDesc';params=method.typeParams;indent='  '}
@end{}
  @DocAnnotation$annotation$(description = "todo")\n
  @TypeInfo("@{genCeylonTypeDecl(method.returnType)}")\n
  @if{concrete}public @end{}
@if{method.staticMethod}static @end{}
@if{method.typeParams.size() > 0}@includeNamed{'genTypeParams';params=method.typeParams} @end{}
@{genJavaInterropTypeDecl(method.returnType)} @{method.name}(@foreach{param:method.params}
\n    final @TypeInfo("@{genCeylonTypeDecl(param.type)}") @DocAnnotation$annotation$(description = "todo") @{genJavaInterropTypeDecl(param.type)} @{param.name}@end{', '})
	@if{concrete} {\n
@{genMethodCall(method, '    ')}
  }\n
	@else{}
;\n
	@end{}
@end{}

@if{!concrete}
\n
  @Ignore\n
  public class Impl@includeNamed{'genTypeParams';params=typeParams} implements @{type.raw.simpleName}@includeNamed{'genTypeParams';params=typeParams} {\n

@includeNamed{'genClassCtor';indent='    ';ctor='Impl'}

@foreach{method:methods}
\n
    @Override\n
    public @{genJavaInterropTypeDecl(method.returnType)} @{method.name}(
@foreach{param:method.params}
final @{genJavaInterropTypeDecl(param.type)} @{param.name}@end{', '}) {\n
@{genMethodCall(method, '      ')}
    }\n
@end{}

  }\n
@end{}


\n
}\n
