@includeNamed{'/vertx-java/template/common-lib.templ'}
@includeNamed{'ceylon-common.templ'}
@code{

  def genConvParam(type, expr) {
    var kind = type.kind;
    if (kind.basic) {
      var sname = type.simpleName;
      if (kind == CLASS_PRIMITIVE) {
        if (sname == 'int' || sname == 'short' || sname == 'float' || sname == 'char') {
          return '(' + sname + ')' + expr;
        }
        return expr;
      } else {
       return genParamConverter(type) + '.safeConvert(' + expr + ')';
      }
    } else if (kind.json) {
       return genParamConverter(type) + '.safeConvert(' + expr + ')';
    } else if (kind == CLASS_HANDLER) {
      var eventType = type.args[0];
      var eventKind = eventType.kind;
      if (eventKind == CLASS_ASYNC_RESULT) {
        var resultType = eventType.args[0];
        var resultKind = resultType.kind;
        var adapterType = resultType.erased;
        return expr + ' == null ? null : new io.vertx.lang.ceylon.AsyncResultAdapter<' + adapterType.name + '>(' + expr + ') {\n' +
        '      public Object toCeylon(' + adapterType.name + ' event) {\n' +
        '        return ' + genConvReturn(adapterType, 'event') + ';\n' +
        '      }\n' +
        '    }';
      } else if (eventKind == CLASS_VOID) {
        /* Special case */
        return expr + ' == null ? null : new ' + type.erased.name + '() {\n' +
        '      public void handle(' + type.erased.args[0].name + ' event) {\n' +
        '        ' + expr + '.$call$();\n' +
        '      }\n' +
        '    }';
      } else {
        return expr + ' == null ? null : new ' + type.erased.name + '() {\n' +
        '      public void handle(' + type.erased.args[0].name + ' event) {\n' +
        '        ' + expr + '.$call$((Object)' + genConvReturn(type.erased.args[0], 'event') + ');\n' +
        '      }\n' +
        '    }';
      }
    } else if (kind == CLASS_API) {
      return type.raw.translateName('ceylon') + '.TO_JAVA.safeConvert(' + expr + ')';
    } else if (kind == CLASS_OBJECT) {
      return 'io.vertx.lang.ceylon.ToJava.object(' + expr + ')';
    } else if (kind == CLASS_DATA_OBJECT) {
      return expr + ' == null ? null : new ' + type.name + '(io.vertx.lang.ceylon.ToJava.JsonObject.convert(' + expr + '.toJson()))';
    } else if (kind == CLASS_ENUM) {
      return genParamConverter(type) + '.safeConvert(' + expr + ')';
    } else if (kind == CLASS_LIST || kind == CLASS_SET) {
      var eltType = type.args[0];
      var collection = kind == CLASS_LIST ? 'io.vertx.lang.ceylon.ToJava.convertList' : 'io.vertx.lang.ceylon.ToJava.convertSet';
      var eltConverter = genParamConverter(eltType);
      if (eltConverter != null) {
        return collection + (eltType.nullable ? 'OfNullable' : '') + '(' + expr + ', ' + eltConverter + ')';
      }
    } else if (kind == CLASS_MAP) {
      var valConverter = genParamConverter(type.args[1]);
      if (valConverter != null) {
        return 'io.vertx.lang.ceylon.ToJava.convertMap' + '(' + expr + ', io.vertx.lang.ceylon.ToJava.String, ' + valConverter + ')';
      }
    }
    return 'null';
  }

  def genParamConverter(type) {
    var kind = type.kind;
    if (kind.basic || kind.json) {
      return 'io.vertx.lang.ceylon.ToJava.' + type.simpleName;
    } else if (kind == CLASS_API) {
      return type.translateName('ceylon') + '.TO_JAVA';
    } else if (kind == CLASS_DATA_OBJECT) {
      return type.translatePackageName('ceylon') + '.toJava' + type.simpleName + '_.get_()';
    } else if (kind == CLASS_ENUM) {
      if (type.gen) {
        return type.translatePackageName('ceylon') + '.toJava' + type.simpleName + '_.get_()';
      } else {
        return 'io.vertx.lang.ceylon.ToJava.enumeration(' + type.name + '.class)';
      }
    }
    return null;
  }

  /*
   * Returns the Ceylon expression that converts a Java object to a Ceylon object.
   * @param type the type of the Java object
   * @param expr the expression that evaluates to the Java object
   */
  def genConvReturn(type, expr) {
    if (type.name.equals("void")) {
      return expr;
    } else {
      var kind = type.kind;
      if (kind.basic || kind == CLASS_THROWABLE || kind.json) {
        if (kind == CLASS_BOXED_PRIMITIVE || kind == CLASS_STRING || kind.json) {
          return 'io.vertx.lang.ceylon.ToCeylon.' + type.simpleName + '.safeConvert(' + expr + ')';
        }
        return expr;
      } else if (kind == CLASS_DATA_OBJECT) {
        return type.translatePackageName('ceylon') + '.toCeylon' + type.simpleName + '_.get_().safeConvert(' + expr + ')';
      } else if (kind == CLASS_LIST || kind == CLASS_SET) {
        var eltType = type.args[0];
        var collection = kind == CLASS_LIST ? 'io.vertx.lang.ceylon.ToCeylon.convertList' : 'io.vertx.lang.ceylon.ToCeylon.convertSet';
        return collection + (eltType.nullable ? 'OfNullable' : '') + '(' + genJavaClassName(eltType, '.') + '.$TypeDescriptor$, ' + expr + ', ' + genReturnConverter(eltType) + ')';
      } else if (kind == CLASS_MAP) {
        var valType =  type.args[1];
        return 'io.vertx.lang.ceylon.ToCeylon.convertMap' + (valType.nullable ? 'OfNullable(' : '(') +
          'ceylon.language.String.$TypeDescriptor$, ' +
          genJavaClassName(valType, '.') + '.$TypeDescriptor$, ' +
          expr + ', ' + 'io.vertx.lang.ceylon.ToCeylon.String, ' + genReturnConverter(valType) + ')';
      } else if (kind == CLASS_API) {
        return type.raw.translateName('ceylon') + '.TO_CEYLON.safeConvert(' + expr + ')';
      } else if (kind.json) {
      } else if (kind == CLASS_OBJECT) {
        return 'io.vertx.lang.ceylon.ToCeylon.object(' + expr + ')';
      } else if (kind == CLASS_ENUM) {
        return genReturnConverter(type) + '.safeConvert(' + expr + ')';
      }
    }
    return 'null';
  }

  def genReturnConverter(type) {
    var kind = type.kind;
    if (kind.basic || kind.json) {
      return 'io.vertx.lang.ceylon.ToCeylon.' + type.simpleName;
    } else if (kind == CLASS_DATA_OBJECT) {
      return type.translatePackageName('ceylon') + '.toCeylon' + type.simpleName + '_.get_()';
    } else if (kind == CLASS_API) {
      return type.translateName('ceylon') + '.TO_CEYLON';
    } else if (kind == CLASS_ENUM) {
      if (type.gen) {
        return type.translatePackageName('ceylon') + '.toCeylon' + type.simpleName + '_.get_()';
      } else {
        return 'io.vertx.lang.ceylon.ToCeylon.<' + type.name + '>enumeration()';
      }
    }
    return null;
  }

  /*
   * Generate Java type declaration for Ceylon interrop.
   */
  def genJavaInterropTypeDecl(type) {
    var decl = "not_handled: " + type + " " + type.class + " " + type.kind;
    var kind = type.kind;
    if (kind == CLASS_API) {
      if (type instanceof io.vertx.codegen.TypeInfo$Parameterized) {
        if (type.raw.concrete) {
          decl = type.raw.simpleName;
        } else {
          decl = genJavaInterropTypeDecl(type.raw);
          var sep = '<';
          for (typeArg : type.args) {
            decl += sep + genJavaInterropTypeDecl(typeArg);
            sep = ',';
          }
          decl += '>';
        }
      } else {
        decl = type.simpleName;
      }
    } else if (kind == CLASS_STRING) {
      decl = 'ceylon.language.String';
    } else if (kind == CLASS_ENUM) {
      if (type.gen) {
        decl = type.translateName('ceylon');
      } else {
        decl = 'ceylon.language.String';
      }
    } else if (kind == CLASS_BOXED_PRIMITIVE) {
      var name = type.name;
      if (name == 'java.lang.Long' || name == 'java.lang.Integer' || name == 'java.lang.Short') {
        decl = 'ceylon.language.Integer';
      } else if (name == 'java.lang.Float' || name == 'java.lang.Double') {
        decl = 'ceylon.language.Float';
      } else if (name == 'java.lang.Boolean') {
        decl = 'ceylon.language.Boolean';
      } else if (name == 'java.lang.Character') {
        decl = 'ceylon.language.Character';
      } else if (name == 'java.lang.Byte') {
        decl = 'ceylon.language.Byte';
      }
    } else if (kind == CLASS_PRIMITIVE) {
      var name = type.name;
      if (name == 'long' || name == 'int' || name == 'short') {
        decl = 'long';
      } else if (name == 'float' || name == 'double') {
        decl = 'double';
      } else if (name == 'boolean') {
        decl = 'boolean';
      } else if (name == 'char') {
        decl = 'int';
      } else if (name == 'byte') {
        decl = 'byte';
      }
    } else if (kind == CLASS_OBJECT) {
      /* handle this instanceof better */
      decl = 'Object';
      if (type instanceof io.vertx.codegen.TypeInfo$Variable) {
        if (type.param instanceof io.vertx.codegen.TypeParamInfo$Class && !type.param.concreteType) {
          decl = type.name;
        }
      }
    } else if (kind == CLASS_HANDLER) {
      var arg = type.args[0];
      decl = 'Callable<?>';
    } else if (kind == CLASS_THROWABLE) {
      decl = 'Throwable';
    } else if (kind == CLASS_DATA_OBJECT) {
      decl = type.translatePackageName('ceylon') + "." + type.simpleName;
    } else if (kind == CLASS_VOID) {
      decl = 'Anything';
    } else if (kind == CLASS_LIST) {
      decl = 'ceylon.language.List<' + genJavaInterropTypeDecl(type.args[0]) + '>';
    } else if (kind == CLASS_SET) {
      if (type.args[0].nullable) {
        decl = 'ceylon.language.Collection<' + genJavaInterropTypeDecl(type.args[0]) + '>';
      } else {
        decl = 'ceylon.language.Set<' + genJavaInterropTypeDecl(type.args[0]) + '>';
      }
    } else if (kind == CLASS_MAP) {
      decl = 'ceylon.language.Map<' + genJavaInterropTypeDecl(type.args[0]) + ',' + genJavaInterropTypeDecl(type.args[1]) + '>';
    } else if (kind == CLASS_JSON_OBJECT) {
      decl = 'ceylon.json.Object';
    } else if (kind == CLASS_JSON_ARRAY) {
      decl = 'ceylon.json.Array';
    } else if (kind == CLASS_OTHER) {
      if (type instanceof io.vertx.codegen.TypeInfo$Void) {
        decl = 'void';
      }
    }
    return decl;
  }

  def genJavaClassName(type, sep) {
    var kind = type.kind;
    if (kind == CLASS_STRING) {
      return 'ceylon.language' + sep + 'String';
    } else if (kind == CLASS_API) {
      return type.raw.translatePackageName('ceylon') + sep + type.simpleName;
    } else if (kind == CLASS_ENUM) {
      if (type.gen) {
        return type.translatePackageName('ceylon') + sep + type.simpleName;
      } else {
        return 'ceylon.language' + sep + 'String';
      }
    } else if (kind == CLASS_BOXED_PRIMITIVE) {
      var name = type.name;
      if (name == 'java.lang.Long' || name == 'java.lang.Integer' || name == 'java.lang.Short') {
        return 'ceylon.language' + sep + 'Integer';
      } else if (name == 'java.lang.Float' || name == 'java.lang.Double') {
        return 'ceylon.language' + sep + 'Float';
      } else if (name == 'java.lang.Boolean') {
        return 'ceylon.language' + sep + 'Boolean';
      } else if (name == 'java.lang.Character') {
        return 'ceylon.language' + sep + 'Character';
      } else if (name == 'java.lang.Byte') {
        return 'ceylon.language' + sep + 'Byte';
      }
    } else if (kind == CLASS_PRIMITIVE) {
      var name = type.name;
      if (name == 'long' || name == 'int' || name == 'short') {
        return 'ceylon.language' + sep + 'Integer';
      } else if (name == 'float' || name == 'double') {
        return 'ceylon.language' + sep + 'Float';
      } else if (name == 'boolean') {
        return 'ceylon.language' + sep + 'Boolean';
      } else if (name == 'char') {
        return 'ceylon.language' + sep + 'Character';
      } else if (name == 'byte') {
        return 'ceylon.language' + sep + 'Byte';
      }
    } else if (kind == CLASS_DATA_OBJECT) {
      return type.translatePackageName('ceylon') + sep + type.simpleName;
    } else if (kind == CLASS_JSON_OBJECT) {
      return 'ceylon.json' + sep + 'Object';
    } else if (kind == CLASS_JSON_ARRAY) {
      return 'ceylon.json' + sep + 'Array';
    }
    return 'todo(' + type + ',' + kind + ')';
  }

  /*
   * Generate Ceylon type declaration.
   */
  def genCeylonTypeDecl(type, allowNullable) {
    var nullable = type.nullable;
    var decl = "not_handled: " + type + " " + type.class + " " + type.kind;
    var kind = type.kind;
    if (kind == CLASS_API) {
      decl = genJavaClassName(type.raw, '::');
      if (type instanceof io.vertx.codegen.TypeInfo$Parameterized) {
        decl = genCeylonTypeDecl(type.raw, allowNullable);
        var sep = '<';
        for (typeArg : type.args) {
          decl += sep + genCeylonTypeDecl(typeArg, false);
          sep = ',';
        }
        decl += '>';
      }
    } else if (kind == CLASS_STRING) {
      decl = genJavaClassName(type, '::');
    } else if (kind == CLASS_ENUM) {
      decl = genJavaClassName(type, '::');
    } else if (kind == CLASS_PRIMITIVE || kind == CLASS_BOXED_PRIMITIVE) {
      decl = genJavaClassName(type, '::');
    } else if (kind == CLASS_OBJECT) {
      nullable = true;
      decl = 'ceylon.language::Object';
      /* handle this instanceof better */
      if (type instanceof io.vertx.codegen.TypeInfo$Variable) {
        if (type.param instanceof io.vertx.codegen.TypeParamInfo$Class && !type.param.concreteType) {
          decl = type.name;
        }
      }
    } else if (kind == CLASS_HANDLER) {
      var arg = type.args[0];
      if (arg.kind == CLASS_VOID) {
        decl = 'ceylon.language::Anything()';
      } else if (arg.kind == CLASS_ASYNC_RESULT) {
        var result = arg.args[0];
        if (result.kind == CLASS_VOID) {
          decl = 'ceylon.language::Anything(ceylon.language::Throwable?)';
        } else {
          decl = 'ceylon.language::Anything(ceylon.language::Throwable|' + genCeylonTypeDecl(result, allowNullable) + ')';
        }
      } else {
        decl = 'ceylon.language::Anything(' + genCeylonTypeDecl(type.args[0], allowNullable) + ')';
      }
    } else if (kind == CLASS_THROWABLE) {
      decl = 'ceylon.language::Throwable';
    } else if (kind == CLASS_DATA_OBJECT) {
      decl = genJavaClassName(type, '::');
    } else if (kind == CLASS_VOID) {
      decl = 'ceylon.language::Anything';
    } else if (kind == CLASS_SET) {
      if (type.args[0].nullable) {
        decl = 'ceylon.language::Collection<' + genCeylonTypeDecl(type.args[0], allowNullable) + '>';
      } else {
        decl = 'ceylon.language::Set<' + genCeylonTypeDecl(type.args[0], allowNullable) + '>';
      }
    } else if (kind == CLASS_LIST) {
      decl = 'ceylon.language::List<' + genCeylonTypeDecl(type.args[0], allowNullable) + '>';
    } else if (kind == CLASS_MAP) {
      decl = 'ceylon.language::Map<' + genCeylonTypeDecl(type.args[0], allowNullable) + ',' + genCeylonTypeDecl(type.args[1], allowNullable) + '>';
    } else if (kind == CLASS_JSON_OBJECT) {
      decl = genJavaClassName(type, '::');
    } else if (kind == CLASS_JSON_ARRAY) {
      decl = genJavaClassName(type, '::');
    } else if (kind == CLASS_OTHER) {
      if (type instanceof io.vertx.codegen.TypeInfo$Void) {
        decl = 'ceylon.language::Anything';
      }
    }
    if (allowNullable && nullable) {
      decl += "?";
    }
    return decl;
  }
}

@declare{'genTypeParams'}
	@if{params.size() > 0}
		<@foreach{param:params}
		@{param.name}
		@end{','}>
	@end{}
@end{}

@code{
  def genMethodCallCeylon(method, indent) {
    var sb = new java.lang.StringBuilder();
    var args = new java.util.ArrayList();
    var idx = 0;
    for (param : method.params) {
      if (param.type.kind == CLASS_API) {
        sb.append(indent).append('assert(is Delegating<').append(genConvParamType(param.type)).append('> arg_').append(idx).append(' = args[').append(idx).append(']);\n');
        args.add('arg_' + idx + '.delegate');
      } else {
        sb.append(indent).append(genConvParam(param.type, 'arg_' + idx, 'args[' + idx + ']')).append(';\n');
        args.add('arg_' + idx);
      }
      idx += 1;
    }
    sb.append(indent);
    if (isGetterMethod(method)) {
      sb.append('Anything v = delegate.').append(toCeylonIdentifier(getPropertyNameFromGetter(method)));
    } else if (isSetterMethod(method)) {
      sb.append('delegate.').append(toCeylonIdentifier(getPropertyNameFromSetter(method))).append(' = ').append(args[0]);
    } else {
      sb.append('Anything v = delegate.').append(toCeylonIdentifier(method.name)).append('(');
      var paramIdx = 0;
      for (param : method.params) {
        if (paramIdx > 0) {
          sb.append(',');
        }
        sb.append(args[paramIdx]);
        paramIdx += 1;
      }
      sb.append(')');
    }
    sb.append(';\n');
    return sb.toString();
  }
}

@code{
  def genMethodCall(method, indent) {
    var sb = new java.lang.StringBuilder();
    var args = new java.util.ArrayList();
    var idx = 0;
    for (param : method.params) {
      var arg = 'arg_' + idx;
      sb.append(indent);
      sb.append(param.type.erased);
      sb.append(' ');
      sb.append(arg);
      sb.append(' = ');
      sb.append(genConvParam(param.type, param.name));
      sb.append(';\n');
      idx += 1;
    }
    var expr = new java.lang.StringBuilder();
    if (method.staticMethod) {
      expr.append(type.raw.name);
    } else {
      expr.append('delegate');
    }
    expr.append('.').append(method.name).append('(');
    var paramIdx = 0;
    for (param : method.params) {
      if (paramIdx > 0) {
        expr.append(', ');
      }
      expr.append('arg_' + paramIdx);
      paramIdx += 1;
    }
    expr.append(')');
    sb.append(indent);
    if (method.returnType.name != 'void') {
      sb.append(genJavaInterropTypeDecl(method.returnType)).append(' ret = ');
    }
    sb.append(genConvReturn(method.returnType, expr.toString()));
    sb.append(';\n');
    return sb.toString();
  }
}

@declare{'genClassMembers'}
	@foreach{method:methods}
		@if{method.cacheReturn}
			@code{cachedType=genJavaInterropTypeDecl(method.returnType)}
			@if{method.returnType.kind == CLASS_PRIMITIVE}
				@if{method.returnType.name == 'boolean'}
					@code{cachedType='java.lang.Boolean'}
				@else{method.returnType.name == 'byte'}
					@code{cachedType='java.lang.Byte'}
				@else{method.returnType.name == 'short' || method.returnType.name == 'int' || method.returnType.name == 'long'}
					@code{cachedType='java.lang.Long'}
				@else{method.returnType.name == 'float' || method.returnType.name == 'double'}
					@code{cachedType='java.lang.Double'}
				@else{method.returnType.name == 'char'}
					@code{cachedType='java.lang.Character'}
				@end{}
			@end{}
@{indent}@Ignore private @{cachedType} cached_@{method.name};\n
		@end{}
	@end{}
@{indent}@Ignore private final @{type.raw.name} delegate;\n
\n
@{indent}public @{ctor}(@{type.raw.name} delegate) {\n
@if{concreteSuperType != null}
@{indent}  super(delegate);\n
@end{}
@{indent}  this.delegate = delegate;\n
@{indent}}\n
\n
@{indent}@Ignore\n
@{indent}public Object getDelegate() {\n
@{indent}  return delegate;\n
@{indent}}\n

@foreach{method:methods}\n
@includeNamed{'genMethodDecl'} {\n
@includeNamed{'genMethodBody'}
@{indent}}\n
@end{}

@end{}

@declare{'genMethodBody'}
	@if{method.cacheReturn}
@{indent}  if (cached_@{method.name} != null) {\n
@{indent}    return cached_@{method.name};\n
@{indent}  }\n
	@end{}
	@{genMethodCall(method, '    ')}
	@if{method.returnType.name != 'void'}
		@if{method.fluent}
@{indent}  return this;\n
		@else{}
			@if{method.cacheReturn}
@{indent}  cached_@{method.name} = ret;\n
			@end{}
@{indent}  return ret;\n
		@end{}
	@end{}
@end{}

@declare{'genMethodDecl'}
  @DocAnnotation$annotation$(description = "todo")\n
  @TypeInfo("@{genCeylonTypeDecl(method.returnType, true)}")\n
  public @if{method.staticMethod}static @end{}
@{genJavaInterropTypeDecl(method.returnType)} @{method.name}(@foreach{param:method.params}
\n    final @TypeInfo("@{genCeylonTypeDecl(param.type, true)}") @Name("@{param.name}") @DocAnnotation$annotation$(description = "todo") @{genJavaInterropTypeDecl(param.type)} @{param.name}@end{', '})
@end{}

@comment{"Generate the imports"}
package @{type.raw.translatePackageName('ceylon')};\n

\n
import com.redhat.ceylon.compiler.java.metadata.TypeInfo;\n
import com.redhat.ceylon.compiler.java.metadata.TypeParameter;\n
import com.redhat.ceylon.compiler.java.metadata.TypeParameters;\n
import com.redhat.ceylon.compiler.java.metadata.Variance;\n
import com.redhat.ceylon.compiler.java.metadata.Ignore;\n
import com.redhat.ceylon.compiler.java.metadata.Name;\n
import com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor;\n
import ceylon.language.Callable;\n
import ceylon.language.DocAnnotation$annotation$;\n
@foreach{importedType:importedTypes}

	@if{importedType.kind == CLASS_DATA_OBJECT}
	@else{importedType.kind == CLASS_API}
		@if{!ifacePackageName.equals(importedType.packageName)}
			import @{importedType.raw.translateName("ceylon")};\n
		@end{}
	@else{importedType.kind == CLASS_ENUM && importedType.gen}
		@if{!ifacePackageName.equals(importedType.packageName)}
			import @{importedType.raw.translateName("ceylon")};\n
			@foreach{value:importedType.values}
			import @{importedType.raw.translateName("ceylon")};\n
			@end{}
		@end{}
	@else{}
		@if{!importedType.packageName.equals("java.lang")}
			import @{importedType};\n
		@end{}
	@end{}
@end{}

\n
@if{typeParams.size() > 0 && !concrete}
	@TypeParameters({\n
		@foreach{typeParam:typeParams}
	  @TypeParameter(value="@{typeParam.name}",variance=Variance.NONE)
		@end{',\n'}
	\n})\n
@end{}
@DocAnnotation$annotation$(description = "todo")\n
public @if{concrete}class@else{}interface@end{} @{type.raw.simpleName}@if{!concrete}@includeNamed{'genTypeParams';params=typeParams}@end{}
@if{concreteSuperType != null} extends @{concreteSuperType.translateName('ceylon')}@end{}
@if{abstractSuperTypes.size() > 0}
	 @if{concrete}implements@else{}extends@end{}
	@foreach{abstractSuperType:abstractSuperTypes}
	 @{genJavaInterropTypeDecl(abstractSuperType)}
	@end{','}
@end{} {\n

\n
  @if{concrete}public static final @end{}TypeDescriptor $TypeDescriptor$ = TypeDescriptor.klass(@{type.raw.simpleName}.class);\n

\n
  @if{concrete}public static final @end{}io.vertx.lang.ceylon.Converter<@{type.raw.name}, @{type.raw.simpleName}> TO_CEYLON = new io.vertx.lang.ceylon.Converter<@{type.raw.name}, @{type.raw.simpleName}>() {\n
    public @{type.raw.simpleName} convert(@{type.raw.name} src) {\n
      return new @{type.raw.simpleName}@if{!concrete}.Impl@end{}(src);\n
    }\n
  };\n

\n
  @if{concrete}public static final @end{}io.vertx.lang.ceylon.Converter<@{type.raw.simpleName}, @{type.raw.name}> TO_JAVA = new io.vertx.lang.ceylon.Converter<@{type.raw.simpleName}, @{type.raw.name}>() {\n
    public @{type.raw.name} convert(@{type.raw.simpleName} src) {\n
@if{concrete}
      return src.delegate;\n
@else{}
      return (@{type.raw.name})src.getDelegate();\n
@end{}
    }\n
  };\n

\n

@if{concrete}

	@includeNamed{'genClassMembers';indent='  ';ctor=type.raw.simpleName}

@else{}

	  @Ignore\n
	  Object getDelegate();\n

	@foreach{method:methods}
		\n
		@includeNamed{'genMethodDecl'};\n
	@end{}

	\n  @Ignore\n
	  public class Impl@includeNamed{'genTypeParams';params=typeParams} implements @{type.raw.simpleName}@includeNamed{'genTypeParams';params=typeParams} {\n
	@includeNamed{'genClassMembers';indent='    ';ctor='Impl'}
	  }\n

@end{}

\n
}\n
